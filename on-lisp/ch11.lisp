(defmacro ry/let (binds &body body)
  `((lambda ,(mapcar #'(lambda (x)
                         (if (consp x)
                             (car x)
                             x))
                     binds)
      ,@body)
    ,@(mapcar #'(lambda (x)
                  (if (consp x)
                      (cadr x)
                      nil))
              binds)))

;; (ry/let ((x 1)
;;          (y 2))
;;   (+ x y))

(defmacro testmacro (expr)
  `(pprint (macroexpand-1 ',expr)))

;; (testmacro (ry/let ((x 1)
;;                     (y 2))
;;              (+ x y)))

(defmacro when-bind ((var expr) &body body)
  `(let ((,var ,expr))
     (when ,var
       ,@body)))

(defmacro when-bind* (binds &body body)
  (if (null binds)
      `(progn ,@body)
      `(let (,(car binds))
         (if ,(caar binds)
             (when-bind* ,(cdr binds) ,@body)))))

;; (when-bind* ((x (find-if #'consp '(a (1 2) b)))
;;              (y (find-if #'oddp x)))
;;   (+ y 10))
;; (find-if #'oddp '(2 4 1))

(defmacro with-gensyms (syms &body body)
  `(let ,(mapcar #'(lambda (s)
                     `(,s (gensym)))
                 syms)
     ,@body))



(defun condlet-clause (vars cl bodfn)
  `(,(car cl) (let ,(mapcar #'cdr vars)
                (let ,(condlet-binds vars cl)
                  (,bodfn ,@(mapcar #'cdr vars))))))

(defun condlet-binds (vars cl)
  (mapcar #'(lambda (bindform)
              (if (consp bindform)
                  (cons (cdr (assoc (car bindform) vars))
                        (cdr bindform))))
          (cdr cl)))

(defmacro condlet (clauses &body body)
  (let ((bodfn (gensym))
        (vars (mapcar #'(lambda (v)
                          (cons v (gensym)))
                      (remove-duplicates
                       (mapcar #'car
                               (mappend #'cdr clauses))))))
    `(labels ((,bodfn ,(mapcar #'car vars)
                ,@body))
       (cond ,@(mapcar #'(lambda (cl)
                           (condlet-clause vars cl bodfn))
                       clauses)))))

;; (testmacro (condlet
;;                (((= 1 2) (x (princ 'a)) (y (princ 'b)))
;;                 ((= 1 1) (x (princ 'c)) (y (princ 'd)))
;;                 (t (x (princ 'e)) (z (princ 'f))))
;;              (list x y z)))

;; 有点懵逼，这后面全是解释
;; test code to understand the code above

;; the code to generate parameter
;; (defun test (clauses &rest rest)
;;   (remove-duplicates (mapcar #'car (mappend #'cdr clauses))))
;; (test '(((= 1 2) (x (princ 'a)) (y (princ 'b)))
;;         ((= 1 1) (x (princ 'c)) (y (princ 'd)))
;;         (t (x (princ 'e)) (z (princ 'f)))))
;; (cdr  (assoc 'x '((x 1) (y 2))))

;; sample output

;; (LABELS ((#:G4002 (Y X Z) (LIST X Y Z)))
;;  (COND
;;   ((= 1 2)
;;    (LET (#:G4003 #:G4004 #:G4005)
;;           ___________________ ==> this is generated by condlet-binds
;;     (LET ((#:G4004 (PRINC 'A)) (#:G4003 (PRINC 'B)))
;;      (#:G4002 #:G4003 #:G4004 #:G4005))))
;;   ((= 1 1)
;;    (LET (#:G4003 #:G4004 #:G4005)
;;     (LET ((#:G4004 (PRINC 'C)) (#:G4003 (PRINC 'D)))
;;      _________________________________ ==> (,bodfn ,@(mapcar #'cdr vars))
;;      (#:G4002 #:G4003 #:G4004 #:G4005))))
;;   (T
;;    (LET (#:G4003 #:G4004 #:G4005)
;;     (LET ((#:G4004 (PRINC 'E)) (#:G4005 (PRINC 'F)))
;;      (#:G4002 #:G4003 #:G4004 #:G4005))))))

;; The names of context building macros often begin with with-.

;; (setq x 'a)
;; (unwind-protect
;;      (progn (princ "what error?")
;;             (error "this error"))
;;   (setq x 'b))


(defmacro if3 (test t-case nil-case ?-case)
  `(case ,test
     ((nil) ,nil-case)
     (? ,?nil-case)
     (t ,t-case)))

(defmacro nif (expr pos zero neg)
  (let ((g (gensym)))
    `(let ((,g ,expr))
       (cond ((plusp ,g) ,pos)
             ((zerop ,g) , zero)
             (t ,neg)))))

;; (mapcar #'(lambda (x)
;;             (nif x 'p 'z 'n))
;;         '(0 1 -1))

(defmacro in (obj &rest choices)
  (let ((insym (gensym)))
    `(let ((,insym ,obj))
       (or ,@(mapcar #'(lambda (c)
                         `(eql ,insym ,c))
                     choices)))))
;; (in t nil nil nil t)
;; (in t nil nil nil nil)

(defmacro inq (obj &rest args)
  `(in ,obj ,@(mapcar #'(lambda (a)
                          `',a)
                      args)))

(defmacro in-if (fn &rest choices)
  (let ((fnsym (gensym)))
    `(let ((,fnsym ,fn))
       (or ,@(mapcar #'(lambda (c)
                         `(funcall ,fnsym ,c))
                     choices)))))


(defun >casex (g cl)
  (let ((key (car cl))
        (rest (cdr cl)))
    (cond ((consp key) `((in ,g ,@key) ,@rest))
          ((inq key t otherwise) `(t ,@rest))
          (t (error "bad >case clause")))))

(defmacro >case (expr &rest clauses)
  (let ((g (gensym)))
    `(let ((,g ,expr))
       (cond ,@(mapcar #'(lambda (cl)
                           (>casex g cl))
                       clauses)))))

;; iteration
(defmacro forever (&body body)
  `(do ()
       (nil)
     ,@body))

(defmacro while (test &body body)
  `(do ()
       ((not ,test))
     ,@body))

(let ((x 1))
  (while (< x 10)
    (princ x)
    (incf x)))

(defmacro till (test &body body)
  `(do ()
       (,test)
    @body))

;; a c like for
(defmacro cfor ((var start stop) &body body)
  (let ((gstop (gensym)))
    `(do ((,var ,start (1+ ,var))
          (,gstop ,stop))
         ((>= ,var ,gstop))
       ,@body)))

(defmacro for ((var start stop) &body body)
  (let ((gstop (gensym)))
    `(do ((,var ,start (1+ ,var))
          (,gstop ,stop))
         ((>= ,var ,gstop))
       ,@body)))

;; (cfor (i 0 10)
;;   (princ i))



;; http://www.paulgraham.com/onlisperrata.html
;; p. 156. In do-tuples/o the expression (1- (length parms)) should be (- (length source) (length parms)).
;; Reported by Roland. (at netquant.com.br)
;; the report is error

(defmacro do-tuples/o (parms source &body body)
  (if parms
      (let ((src (gensym)))
        `(prog ((,src ,source))
            (mapc #'(lambda ,parms ,@body)
                  ,@(map0-n #'(lambda (n)
                                `(nthcdr ,n ,src))
                            (1- (length parms))))))))

;; (testmacro (do-tuples/o (x y) '(a b c d)
;;              (princ (list x y))))
;; (do-tuples/o (x y) '(a b c d)
;;   (princ (list x y)))

;; (mapc #'(lambda (x y)
;;           (princ x)
;;           (princ y))
;;       '(a b c d)
;;       '(b c d))


(defmacro do-tuples/c (parms source &body body)
  (if parms
      (with-gensyms (src rest bodfn)
        (let ((len (length parms)))
          `(let ((,src ,source))
             (when (nthcdr ,(1- len) ,src)
               (labels ((,bodfn ,parms ,@body))
                 (do ((,rest ,src (cdr ,rest)))
                     ((not (nthcdr ,(1- len) ,rest))
                      ,@(mapcar (lambda (args)
                                  `(,bodfn ,@args))
                                (dt-args len rest src))
                      nil)
                   (,bodfn ,@(map1-n (lambda (n)
                                       `(nth ,(1- n)
                                             ,rest))
                                     len))))))))))


(defun dt-args (len rest src)
  (map0-n (lambda (m)
            (map1-n (lambda (n)
                      (let ((x (+ m n)))
                        (if (>= x len)
                            `(nth ,(- x len) ,src)
                            `(nth ,(1- x) ,rest))))
                    len))
          (- len 2)))

;; (do-tuples/c (x y) '(a b c d)
;;   (princ (list x y)))

;; (testmacro (do-tuples/c (x y) '(a b c d)
;;              (princ (list x y))))

;; to help understand do-tuples/c
;; (let ((lst '(a b c d)))
;;   (when (nthcdr 1 lst)
;;     (labels ((help (x y)
;;                (princ (list x y))))
;;       (do ((i lst (cdr i)))
;;           ((not (nthcdr 1 i))
;;            (help (nth 0 i) (nth 0 lst)) nil)
;;         (help (nth 0 i) (nth 1 i))))))

(defmacro mvdo* (parm-cl test-cl &body body)
  (mvdo-gen parm-cl parm-cl test-cl body))

(defun mvdo-gen (binds rebinds test body)
  (if (null binds)
      (let ((label (gensym)))
        `(prog nil
            ,label
            (if ,(car test)
                (return (progn ,@(cdr test))))
            ,@body
            ,@(mvdo-rebind-gen rebinds)
            (go ,label)))
      (let ((rec (mvdo-gen (cdr binds) rebinds test body)))
        (let ((var/s (caar binds))
              (expr (cadar binds)))
          (if (atom var/s)
              `(let ((,var/s ,expr))
                 ,rec)
              `(multiple-value-bind ,var/s ,expr ,rec))))))

(defun mvdo-rebind-gen (rebinds)
  (cond ((null rebinds) nil)
        ((< (length (car rebinds)) 3)
         (mvdo-rebind-gen (cdr rebinds)))
        (t (cons (list (if (atom (caar rebinds))
                           `setq
                           `multiple-value-setq)
                       (caar rebinds)
                       (third (car rebinds)))
                 (mvdo-rebind-gen (cdr rebinds))))))

;; (testmacro (mvdo* ((x 1 (1+ x))
;;                    ((y z) (values 0 0) (values z x)))
;;                ((> x 5) (list x y z))
;;              (princ (list x y z))))

;; (mvdo* ((x 1 (1+ x))
;;                    ((y z) (values 0 0) (values z x)))
;;                ((> x 5) (list x y z))
;;              (princ (list x y z)))

;; (list* 1 2)
;; (list* 1)

(defun shuffle (x y)
  (cond ((null x) y)
        ((null y) x)
        (t (list* (car x) (car y)
                  (shuffle (cdr x) (cdr y))))))
;; (shuffle '(x y z) '(a b c))

(defmacro mvpsetq (&rest args)
  (let* ((pairs (group args 2))
         (syms (mapcar #'(lambda (p)
                           (mapcar #'(lambda (x)
                                       (gensym))
                                   (mklist (car p))))
                       pairs)))
    (labels ((rec (ps ss)
               (if (null ps)
                   `(setq
                     ,@(mapcan #'(lambda (p s)
                                   (shuffle (mklist (car p))
                                            s))
                               pairs syms))
                   (let ((body (rec (cdr ps) (cdr ss))))
                     (let ((var/s (caar ps))
                           (expr (cadar ps)))
                       (if (consp var/s)
                           `(multiple-value-bind ,(car ss)
                                ,expr ,body)
                           `(let ((,@(car ss) ,expr))
                              ,body)))))))
      (rec pairs syms))))

;; (testmacro (mvpsetq (w x) (values 'a 'b) (y z) (values w x)))

;; (let ((w 0) (x 1) (y 2) (z 3))
;;               (mvpsetq (w x) (values 'a 'b) (y z) (values w x))
;;               (list w x y z))
